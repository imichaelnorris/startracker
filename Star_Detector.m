%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Computer Vision Final Project
% Matthew Walmer - mwalmer3
%
% Star Detector - Scans image and segments all stars. Computes star centers
% with sub-pixel accuracy, and then computes the body vector for each star
% by projecting onto the unit sphere. Also, each detected star is
% classified as 'uv-active' or not based on it's ratio of visible spectrum
% brightness to uv-spectrum brightness
%
% Inputs
%   vis_filename    Filename for the visual spectrum star image
%   uv_filename     Filename for the uv-spectrum star image
%   cp_filename     Filename for the .mat file with the camera parameters
%                   (generated by Sim_Star_Image.m). Should include fx, fy
%                   o_x and o_y (focal lengths and principal point)                   
%   showIm          If true, the program will display an overlay of what
%                   stars it detected. Defaults to false.
%   gt_filename     (Optional) Filename of the ground truth file for the
%                   simulated star images (generated by Sim_Star_Image.m).
%                   If included and showIm = true, the program will display
%                   an overlay comparing the found stars to the true stars
%
% Outputs:
%  body_vectors     An Nx3 matrix containing 3D coordinates of the detected
%                   stars projected onto the unit sphere.
%  centers          An Nx2 matrix containing 2D sub-pixel coordinates of
%                   the detected stars' centers in the image
%  uv_active        An Nx1 boolean matrix stating whether each star is
%                   considered uv-active. A star is uv-active if it's ratio
%                   of uv-brightness to visible spectrum brightness is high
%                   enough.
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

function [body_vectors, centers, uv_active] = Star_Detector(vis_filename, uv_filename, cp_filename, showIm, gt_filename)
if nargin < 4
    showIm = false;
end

% scanning radius when precise star centroids and UV content
% (depends on defocus radius of image, aim for 3*sig where sig is the sigma
% of the blur PSF)
win_rad = 3;

im_vis = im2double(imread(vis_filename));
im_uv = im2double(imread(uv_filename));

%Apply gaussian filter to remove noise
g = fspecial('gaussian',[5 5],1);
im_vis_blur = conv2(im_vis,g,'same');

%UV activity Threshold - minimal ratio of uv-brightness/vis-spectrum-brightness
%for a star to be considered UV-active
min_uv_temp = 6000; %K - Used to calculate min UV-ratio using black-body radiation formula
min_uv_ratio = UV_fraction_by_T(min_uv_temp);

%load camera parameters
load(cp_filename);

%determine binary threshold using mean and standard deviation
thresh = mean(im_vis_blur(:)) + 5 * std(im_vis_blur(:));
mv = mean(im_vis(:));   %mean brightness in vis-image
mu = mean(im_uv(:));    %mean brightness in uv-image

%create binary image of visual-spectrum image
im_bin = im_vis_blur >= thresh;

%alternative: create binary image from both vis-spectrum image + uv image:
%pro: better at detecting UV-stars, con: less discriminative on basic of
%visible spectrum apparent magnitude
% im_uv_blur = conv2(im_uv,g,'same');
% thresh_uv = mean(im_uv_blur(:)) + 5 * std(im_uv_blur(:));
% im_bin = (im_vis_blur >= thresh) | (im_uv_blur >= thresh_uv);

labels = zeros(size(im_bin)); % will hold segmentation labels

% representing equivalence relations using union-find graph
equiv = containers.Map('KeyType','double','ValueType','double');

next_tag = 1; % next un-used tag

% raster scan first pass labelling
% assumes there are not objects on row 1 and column 1
for i = 2:size(im_bin,1)
    for j = 2:size(im_bin,2)
        if im_bin(i,j) ~= 0
            D = labels(i-1,j-1);
            C = labels(i,j-1);
            B = labels(i-1,j);
            if D ~= 0 % label(A) = label(D)
                labels(i,j) = D;
            elseif C ~= 0 && B == 0 % label(A) = label(C)
                labels(i,j) = C;
            elseif B ~= 0 && C == 0 % label(A) = label(B)
                labels(i,j) = B;
            elseif B == C
                if B == 0 % label(A) = new tag
                    labels(i,j) = next_tag;
                    next_tag = next_tag + 1;
                else % label(A) = label(B) = label(C)
                    labels(i,j) = B;
                end
            else % B,C != 0, B != C -> merge segments case
                labels(i,j) = C;
                % make label(B) == label(C) in the equivalence graph by connecting their roots
                if ~isKey(equiv, B)
                    equiv(B) = B; % add B as a new roots if not already in graph
                end
                if ~isKey(equiv, C)
                    equiv(C) = C; % add C as a new roots if not already in graph
                end
                equiv(uf_root(C, equiv)) = uf_root(B, equiv);
            end
        end
    end
end

%create dictionary mapping unique labels to sequential integers (database
%index = dbi)
dbi = containers.Map('KeyType','double','ValueType','double');
num_stars = 0; %number of unique labels (after second pass) -> num_stars

% second pass to fix equivalences
for i = 1:size(im_bin,1)
    for j = 1:size(im_bin,2)
        if labels(i,j) ~= 0
            k = labels(i,j);
            if isKey(equiv, k)
                labels(i,j) = uf_root(k, equiv);
            end
            if ~isKey(dbi, labels(i,j))
                num_stars = num_stars + 1;
                dbi(labels(i,j)) = num_stars;
            end
        end
    end
end

%for each star, compute approximate centroid using segmented binary image:
area = zeros(num_stars,1);
first_mom_i = zeros(num_stars,1); %first moment in i direction for each star
first_mom_j = zeros(num_stars,1); %first moment in j direction for each star
for i = 1:size(im_bin,1)
    for j = 1:size(im_bin,2)
        if labels(i,j) ~= 0
            k = dbi(labels(i,j));
            area(k) = area(k) + 1;
            first_mom_i(k) = first_mom_i(k) + i;
            first_mom_j(k) = first_mom_j(k) + j;
        end
    end
end
approx_centers = [first_mom_j./area, first_mom_i./area]; 

%compute precise centers (with sub pixel accuracy) by scanning local area
%around each approximate star center, using intensity values as weight.
centers = zeros(size(approx_centers));
uv_active = false(num_stars,1); %track which stars are considered UV active

k = 1;
while k <= size(approx_centers,1)
    i_c = round(approx_centers(k,2)); 
    j_c = round(approx_centers(k,1));
    i_range = i_c-win_rad:i_c+win_rad;
    j_range = j_c-win_rad:j_c+win_rad;
    [Jr,Ir] = meshgrid(j_range,i_range);
    try
        A = Ir .* im_vis(i_range, j_range);
        first_mom_i = sum(A(:)); % first moment in i direction
        A = Jr .* im_vis(i_range, j_range);
        first_mom_j = sum(A(:)); % first moment in j direction
        A = im_vis(i_range, j_range);
        TB = sum( A(:) ); %total vis-spectrum brightness
        A = im_uv(i_range, j_range);
        TB_uv = sum( A(:) ); %total uv-brightness
        
        V = size(A,1)*size(A,2);
        % classify if uv-active. For each brightness, normalize by
        % subtracting out the mean brightness for each image
        uv_active(k) = ( (TB_uv-V*mu)/(TB-V*mv) >= min_uv_ratio );
        
        centers(k,:) = [first_mom_j/TB, first_mom_i/TB];
        k = k+1; %progress
    catch
        %An out of matrix error will be thrown if the center is too close
        %to the edge of the image. Just ignore these centers.
        approx_centers(k,:) = [];
        continue
    end
end
centers = centers(1:size(approx_centers,1),:); %truncate
uv_active = uv_active(1:size(approx_centers,1));

% from centers, compute body vectors
body_vectors = [ (centers(:,1)-o_x)/fx, (centers(:,2)-o_y)/fy, ones(num_stars,1) ];
body_vectors = body_vectors ./ repmat(sqrt( body_vectors(:,1).^2 + body_vectors(:,2).^2 + body_vectors(:,3).^2 ),1,3);

%Optional - display image
if showIm
    figure;
    imshow(im_vis);
    hold on
    % plot detected stars. color code based on uv-active
    % magenta = uv-active, yellow = not.
    for k = 1:num_stars
        if uv_active(k)
            plot(centers(k,1),centers(k,2),'om');
        else
            plot(centers(k,1),centers(k,2),'oy');
        end
    end
    % if ground truth file included, plot ground truth points with x's.
    % and color code the same way as above.
    if nargin > 4
        load(gt_filename); %load ground truth points
        for k = 1:size(im_list,1)
            if im_list_class(k) < 5
                plot(im_list(k,1),im_list(k,2),'.m');
            else
                plot(im_list(k,1),im_list(k,2),'.y');
            end
        end
    end
    title('o = Detected Stars, . = Ground Truth (optional), Magenta = UV-active, Yellow = Not UV-active')
end

end